(define (matrix-chain-order p)
  (let ((n (- (length p) 1)))
    (let ((m (make-array '#(+inf.0) n n))
          (s (make-array '#(#f) n n)))
      (loop ((for i (up-from 0 (to n))))
            (array-set! m 0 i i))
      (loop ((for l (up-from 2 (to (+ n 1)))))
            (loop ((for i (up-from 0 (to (+ (- n l) 1)))))
                  (let ((j (- (+ i l) 1)))
                    (loop ((for k (up-from i (to j))))
                          (let ((q (+ (array-ref m i k)
                                      (array-ref m (+ k 1) j)
                                      (* (list-ref p i)
                                         (list-ref p (+ k 1))
                                         (list-ref p (+ j 1))))))
                            (if (< q (array-ref m i j))
                                (begin (array-set! m q i j)
                                       (array-set! s k i j))))))))
      (values m s))))

(define (matrix-multiply A B)
  (let ((dim-A (array-dimensions A))
        (dim-B (array-dimensions B)))
    (let ((p (car dim-A))
          (q (cadr dim-A))
          (r (car dim-B))
          (s (cadr dim-B)))
      (if (not (= q r))
          (error "nicht going to worken, freund -- MATRIX-MULTIPLY"
                 `((,p ,q) (,r ,s))))
      (array-index-map!
       (make-array p s)
       (lambda (x y)
         (let ((row (make-shared-array A (lambda (i) (list x i)) q))
               (col (make-shared-array B (lambda (j) (list j y)) q)))
           (let ((multiplicata (array-map '#(#f) * row col)))
             (array-fold + 0 multiplicata))))))))

;;; Ã…smund Eldhuset dispatches instead on (= (+ i 1) j) with
;;; (matrix-multiply (list-ref A i) (list-ref A
;;; j). <http://www.idi.ntnu.no/~algdat/notater/2007/lf-kap15.pdf>
(define (matrix-chain-multiply A s i j)
  (if (= i j)
      (list-ref A i)
      (matrix-multiply (matrix-chain-multiply A s i (array-ref s i j))
                       (matrix-chain-multiply A s (+ (array-ref s i j) 1) j))))

(define (matrix-chain-multiply/straight matrices)
  (fold (lambda (B A) (matrix-multiply A B))
        (car matrices)
        (cdr matrices)))

(define (random-matrix p q)
  (let ((array (make-array p q)))
    (array-index-map! array (lambda (x y) (random-integer (expt 2 8))))
    array))

(define (random-matrices p)
  (let ((lower-bounds (drop-right p 1))
        (upper-bounds (drop p 1)))
    (map (lambda (p q) (random-matrix p q))
         lower-bounds
         upper-bounds)))
