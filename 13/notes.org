#+OPTIONS: num:nil
#+TITLE: Chapter 13
* 13.1
  - binary tree with color (two-way coloring)
  - red-black constraint ensures that no path is more than twice as
    long as any other: balanced.
  - red-black properties:
    1. every node red or black
    2. root: black
    3. every leaf (nil): black
    4. if a node is red: both children are black
    5. all path from a node to leaves contain the same number of black nodes.
  - single sentinel represents =nil=.
  - black height: black nodes on any path from, but not including,
    node x.
  - red-black tree with n internal nodes has height at most $2\lg(n + 1)$
  - subtree rooted at x contains at least $2^{bh(k)} - 1$ internal
    nodes.
  - black-height of root at least $h/2$; thus: $n \geq 2^{h/2} - 1$
** Exercises
*** 13.1-1
    See [[../13.1/13.1-3a.dot]], [[../13.1/13.1-3a.png]], [[../13.1/13.1-3b.dot]],
    [[../13.1/13.1-3b.png]].
*** 13.1-2
    See [[../13.1/13.1-2.dot]], [[../13.1/13.1-2.png]], [[../13.1/13.1-2.txt]].
*** 13.1-3
    See [[../13.1/13.1-3.txt]].
*** 13.1-4
    See [[../13.1/13.1-4.txt]].
*** 13.1-5
    See [[../13.1/13.1-5.txt]].
*** 13.1-6
    $h \geq 2\lg(n + 1)$; how does h relate to bh, though?
    #+BEGIN_QUOTE
    red-black trees ensure that no such path is more than twice as
    long as any other. (275)
    #+END_QUOTE
    moreover:
    #+BEGIN_QUOTE
    consequently, the black-height of the root must be at least
    $h/2$. (276)
    #+END_QUOTE
    #+BEGIN_QUOTE
    according to property 4, at least half the nodes on any simple
    path from the root to a leaf, not including tho root, must be
    black. (274)
    #+END_QUOTE
    $n \geq 2^{bh(x)} - 1$; $bh(x) \geq h/2$; $n \geq 2^{bh(x)} - 1
    \geq 2^{h/2} - 1$. Where $bh(x) = k$, the smallest number gives
    itself immediately:
    #+BEGIN_QUOTE
    $n \geq 2^k - 1$
    #+END_QUOTE
    "internal nodes," by the way, are the non-nil nodes from root to
    leaf (excluding leaves).

    the largest red-black tree of a $bh = k$ is one in which the rows
    alternate black-red (proof?): the only way to expand such a tree
    would be to add a black node, contradicting $bh = k$. such a tree
    has $2^h - 1$ = $2^{2k} - 1$ internal nodes (need to be able to
    derive this stuff ourselves); therefore:

    #+BEGIN_QUOTE
    $2^k - 1 \leq n \leq 2^{2k} - 1$
    #+END_QUOTE
*** 13.1-7
    See [[../13.1/13.1-7.txt]].

* 13.2
  - =tree-insert= and =tree-delete= take O(lg n); because they modify
    the tree, they may violate the red-black properties: must restore
    them.
  - change pointer structure through *rotation*
  - left-rotation on any x whose right-child y is non-nil;
    left-rotation pivots around the link from x to y: makes y the new
    root of the subtree; with x as y's left child and y's left child
    as x's right child.
    - keeps x's left child?
  - rotation preserves the binary search tree property.
  #+BEGIN_SRC org
    ,- left-rotate(T, x)
    ,  - y = right[x]                # let y be the right child of x.
    ,  - right[x] = left[y]          # let y's left child be x's right.
    ,  - if left[y] != nil[T]        # if y has a left child,
    ,    - then p[left[y]] = x       # let x be y's left child's parent.
    ,  - p[y] = p[x]                 # let y's parent be x's parent.
    ,  - if p[x] = nil[T]            # if x is root,
    ,    - then root[T] = y          # let y be the new root (so we have to
    ,                                # do tree objects with roots; the node
    ,                                # itself doesn't suffice);
    ,    - else if x = left[p[x]]    # otherwise, if x is its parent's left
    ,                                # child,
    ,      - then left[p[x]] = y     # let y be x's parent's left child;
    ,      - else right[p[x]] = y    # otherwise, let y be x's parent's
    ,                                # right child.
    ,  - left[y] = x                 # let x be y's right child.
    ,  - p[x] = y                    # let y be the parent of x.
  #+END_SRC
  - the code for =right-rotate= is symmetric.
  - =right-= and =left-rotate= appear to be inverse.
** Exercises
*** 13.2-1
    need to reorder the =lets= below, such that the assignee is on
    the left
    #+BEGIN_SRC org
      ,- right-rotate(T, y)
      ,  - x = left[y]                 # let x be the left child of y.
      ,  - left[y] = right[x]          # let x's right child be y's left.
      ,  - if right[x] != nil[T]       # if x has a right child,
      ,    - then p[right[x]] = y      # let y be x's right child's parent.
      ,  - p[x] = p[y]                 # let x's parent be y's parent.
      ,  - if p[y] = nil[T]            # if y is root,
      ,    - then root[T] = x          # let x be the new root (so we have to
      ,                                # do tree objects with roots; the node
      ,                                # itself doesn't suffice);
      ,    - else if y = right[p[y]]   # otherwise, if y is its parent's right
      ,                                # child,
      ,      - then right[p[y]] = x    # let x be y's parent's right child;
      ,      - else left[p[y]] = x     # otherwise, let x be y's parent's
      ,                                # left child.
      ,  - right[x] = y                # let y be x's left child.
      ,  - p[y] = x                    # let x be the parent of y.
    #+END_SRC
*** 13.2-2
    In an $n$-node binary tree, there an $n - 1$ children; since the
    root is the child of no node. The criterion of rotatability is the
    presence of a child; there are therefore $n - 1$ ways to rotate,
    corresponding to the $n - 1$ children.
*** 13.2-3
    $a$ is increased by one; $b$ stays the same; $c$ loses one.
*** 13.2-4
    [[http://www.cs.cmu.edu/~sleator/papers/Rotation-Distance.htm][Sleator]] (1988) nakedly asserts that:
    #+BEGIN_QUOTE
    Any binary tree of size n can be converted into any other by
    performing an appropriate sequence of rotations.
    #+END_QUOTE
    [[http://en.wikipedia.org/wiki/Tree_rotation][interesting]]:
    #+BEGIN_QUOTE
    Associativity of a binary operation means that performing a tree
    rotation on it does not change the final result.
    #+END_QUOTE
    Given two BSTs T and T', transform T into a right-going chain by
    right-rotating all of its left children in no more than $n - 1$
    rotations (there can be no more than $n - 1$ left children); do
    the same for $T'$ in $O(2n - 2) = O(n)$.
*** TODO 13.2-5
