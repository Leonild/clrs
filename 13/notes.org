#+OPTIONS: num:nil
#+TITLE: Chapter 13
* 13.1
  - binary tree with color (two-way coloring)
  - red-black constraint ensures that no path is more than twice as
    long as any other: balanced.
  - red-black properties:
    1. every node red or black (<<property 1>>)
    2. root: black (<<property 2>>)
    3. every leaf (nil): black (<<property 3>>)
    4. if a node is red: both children are black (<<property 4>>)
    5. all path from a node to leaves contain the same number of black
       nodes. (<<property 5>>)
  - single sentinel represents =nil=.
  - black height: black nodes on any path from, but not including,
    node x.
  - red-black tree with n internal nodes has height at most $2\lg(n + 1)$
  - subtree rooted at x contains at least $2^{bh(k)} - 1$ internal
    nodes.
  - black-height of root at least $h/2$; thus: $n \geq 2^{h/2} - 1$
** Exercises
*** 13.1-1
    See [[../13.1/13.1-3a.dot]], [[../13.1/13.1-3a.png]], [[../13.1/13.1-3b.dot]],
    [[../13.1/13.1-3b.png]].
*** 13.1-2
    See [[../13.1/13.1-2.dot]], [[../13.1/13.1-2.png]], [[../13.1/13.1-2.txt]].
*** 13.1-3
    See [[../13.1/13.1-3.txt]].
*** 13.1-4
    See [[../13.1/13.1-4.txt]].
*** 13.1-5
    See [[../13.1/13.1-5.txt]].
*** 13.1-6
    $h \geq 2\lg(n + 1)$; how does h relate to bh, though?
    #+BEGIN_QUOTE
    red-black trees ensure that no such path is more than twice as
    long as any other. (275)
    #+END_QUOTE
    moreover:
    #+BEGIN_QUOTE
    consequently, the black-height of the root must be at least
    $h/2$. (276)
    #+END_QUOTE
    #+BEGIN_QUOTE
    according to property 4, at least half the nodes on any simple
    path from the root to a leaf, not including tho root, must be
    black. (274)
    #+END_QUOTE
    $n \geq 2^{bh(x)} - 1$; $bh(x) \geq h/2$; $n \geq 2^{bh(x)} - 1
    \geq 2^{h/2} - 1$. Where $bh(x) = k$, the smallest number gives
    itself immediately:
    #+BEGIN_QUOTE
    $n \geq 2^k - 1$
    #+END_QUOTE
    "internal nodes," by the way, are the non-nil nodes from root to
    leaf (excluding leaves).

    the largest red-black tree of a $bh = k$ is one in which the rows
    alternate black-red (proof?): the only way to expand such a tree
    would be to add a black node, contradicting $bh = k$. such a tree
    has $2^h - 1$ = $2^{2k} - 1$ internal nodes (need to be able to
    derive this stuff ourselves); therefore:

    #+BEGIN_QUOTE
    $2^k - 1 \leq n \leq 2^{2k} - 1$
    #+END_QUOTE
*** 13.1-7
    See [[../13.1/13.1-7.txt]].

* 13.2
  - =tree-insert= and =tree-delete= take O(lg n); because they modify
    the tree, they may violate the red-black properties: must restore
    them.
  - change pointer structure through *rotation*
  - left-rotation on any x whose right-child y is non-nil;
    left-rotation pivots around the link from x to y: makes y the new
    root of the subtree; with x as y's left child and y's left child
    as x's right child.
    - keeps x's left child?
  - rotation preserves the binary search tree property.
  #+BEGIN_SRC org
    ,- left-rotate(T, x)
    ,  - y = right[x]                # let y be the right child of x.
    ,  - right[x] = left[y]          # let y's left child be x's right.
    ,  - if left[y] != nil[T]        # if y has a left child,
    ,    - then p[left[y]] = x       # let x be y's left child's parent.
    ,  - p[y] = p[x]                 # let y's parent be x's parent.
    ,  - if p[x] = nil[T]            # if x is root,
    ,    - then root[T] = y          # let y be the new root (so we have to
    ,                                # do tree objects with roots; the node
    ,                                # itself doesn't suffice);
    ,    - else if x = left[p[x]]    # otherwise, if x is its parent's left
    ,                                # child,
    ,      - then left[p[x]] = y     # let y be x's parent's left child;
    ,      - else right[p[x]] = y    # otherwise, let y be x's parent's
    ,                                # right child.
    ,  - left[y] = x                 # let x be y's right child.
    ,  - p[x] = y                    # let y be the parent of x.
  #+END_SRC
  - the code for =right-rotate= is symmetric.
  - =right-= and =left-rotate= appear to be inverse.
** Exercises
*** 13.2-1
    need to reorder the =lets= below, such that the assignee is on
    the left
    #+BEGIN_SRC org
      ,- right-rotate(T, y)
      ,  - x = left[y]                 # let x be the left child of y.
      ,  - left[y] = right[x]          # let x's right child be y's left.
      ,  - if right[x] != nil[T]       # if x has a right child,
      ,    - then p[right[x]] = y      # let y be x's right child's parent.
      ,  - p[x] = p[y]                 # let x's parent be y's parent.
      ,  - if p[y] = nil[T]            # if y is root,
      ,    - then root[T] = x          # let x be the new root (so we have to
      ,                                # do tree objects with roots; the node
      ,                                # itself doesn't suffice);
      ,    - else if y = right[p[y]]   # otherwise, if y is its parent's right
      ,                                # child,
      ,      - then right[p[y]] = x    # let x be y's parent's right child;
      ,      - else left[p[y]] = x     # otherwise, let x be y's parent's
      ,                                # left child.
      ,  - right[x] = y                # let y be x's left child.
      ,  - p[y] = x                    # let x be the parent of y.
    #+END_SRC
*** 13.2-2
    In an $n$-node binary tree, there an $n - 1$ children; since the
    root is the child of no node. The criterion of rotatability is the
    presence of a child; there are therefore $n - 1$ ways to rotate,
    corresponding to the $n - 1$ children.
*** 13.2-3
    $a$ is increased by one; $b$ stays the same; $c$ loses one.
*** 13.2-4
    [[http://www.cs.cmu.edu/~sleator/papers/Rotation-Distance.htm][Sleator]] (1988) nakedly asserts that:
    #+BEGIN_QUOTE
    Any binary tree of size n can be converted into any other by
    performing an appropriate sequence of rotations.
    #+END_QUOTE
    [[http://en.wikipedia.org/wiki/Tree_rotation][Interesting]]:
    #+BEGIN_QUOTE
    Associativity of a binary operation means that performing a tree
    rotation on it does not change the final result.
    #+END_QUOTE
    Given two BSTs T and T', transform T into a right-going chain by
    right-rotating all of its left children in no more than $n - 1$
    rotations (there can be no more than $n - 1$ left children); do
    the same for $T'$ (but in reverse) in $O(2n - 2) = O(n)$.
*** TODO 13.2-5
* 13.3
  - insert in $O(\lg n)$
  - insert as in BST; color node red; run auxiliary fix-up (which
    recolors and rotates).
  #+BEGIN_SRC org
    ,- rb-insert(T, z)
    ,  - y = nil[T]                  # let y be the nil-sentinel (the
    ,                                # default case, in case of an empty
    ,                                # tree
    ,  - x = root[T]                 # start from the root
    ,  - while x != nil[T]           # progress down to the sentinel-leaves
    ,    - do y = x                  # y is one behind x, and will
    ,                                # eventually be the parent of the
    ,                                # leaf-sentinel
    ,      - if key[z] < key[x]      # compare z's and x' key so as to
    ,                                # uphold the binary search tree property.
    ,        - then x = left[x]      # left branches are smaller
    ,        - else x = right[x]     # right branches are greater than or
    ,                                # equal to
    ,  - p[z] = y                    # attach z to the penultimate node
    ,  - if y = nil[T]               # if the tree is empty,
    ,    - then root[T] = z          # z is the new root;
    ,    - else if key[z] < key[y]   # otherwise, attach z to the
    ,                                # appropriate branch so as to
    ,                                # uphold the BST property
    ,      - then left[y] = z
    ,      - else right[y] = z
    ,  - left[z] = nil[T]            # since z is a penultimate leaf,
    ,                                # add the nil-sentinels.
    ,  - right[z] = nil[T]
    ,  - color[z] = RED              # not sure why this is not black:
    ,                                # presumptuous to alter the
    ,                                # black-height unilaterally?
    ,  - rb-insert-fixup(T, z)       # recolor, rotate as needed.
  #+END_SRC
  - interestingly, $z$ is never re-colored during rb-insert-fixup; it
    should be, though, if it violates 2 (i.e. is root): then it should
    be re-colored at line 16: $color[root[T]] \gets BLACK$.
  - both the parent and children of the root are sentinel; violation
    of property 2 is the only violation.
  - case 1: p[z] and z's uncle y = {right,left}[p[p[z]]] are red.
    - since p[p[z]] is black (why? because red nodes must be preceded
      by black nodes; where are black nodes can be preceded by either
      red or black), we can color both p[z] and y black, fixing the
      problem of z and p[z] both being red; and color p[p[z]] red,
      maintaining property 5. repeat the while loop with p[p[z]] as
      the new node z.
  - case 2, 3: z's uncle y = {right,light}[p[p[z]]] is black and (2) z
    is a left or (3) z is a right child.
    - eventual goal is a rotation around a three-fold
      {left,right}-going chain and recoloring of the top
      node. {left,right}-rotate the bottom node first (case 2), if
      necessary; this leads to case 3 (rotation, recolor).
    - we immediately use a left rotation to transform the situation
      into case 3; beacuse both z and p[z] are red, the rotation
      affects neither the black-height of nodes nor property 5 (see
      [[13.2-3]]).
    - z's uncle is black; also, p[p[z]] exists.
    - upon case 3, color changes and right rotation; preserves
      [[property 5]].
    - p[z] is now black; body of while is not executed again.
    - rb-insert-fixup climbs up the tree by grand-parents, is
      therefore $O(\lg n)$; rb-insert is moreover $O(\lg n)$.
  #+BEGIN_SRC org
    ,- rb-insert-fixup(T, z)
    ,  - while color[p[z]] = RED # z, i believe, is guaranteed to be red
    ,    (even in subsequent invocations of the while loop); such that we
    ,    need not continue if we have a black parent: where no such
    ,    black->{red,black} constraint exists
    ,    - do if p[z] = left[p[p[z]]] # depending upon whether z is a left
    ,      or right grandchild (and, thus, has a right of left uncle,
    ,      respectively), do this
    ,        - then y = right[p[p[z]]] # y is the right uncle
    ,          - if color[y] = RED # p[z] is red; so p[p[z]] must be black;
    ,            therefore, toggle the colors of the grandparent, parent
    ,            and uncle; preserving [[property 5]]. start the =while= anew
    ,            from the grandparent, which may still violate [[property 4]];
    ,            but not [[property 2]]? yes, possibly 2; in which case it will
    ,            simply be blackened after the next =while= iteration;
    ,            leaving two black children (no contradiction).
    ,            - then color[p[z]] = BLACK
    ,              - color[y] = BLACK
    ,              - color[p[p[z]]] = RED
    ,              - z = p[p[z]]
    ,            - else if z = right[p[z]] # if case 2 holds, convert it
    ,              into a case 3 (left-going chain) before rotation.
    ,                - then z = p[z]
    ,                  - left-rotate(T, z)
    ,              - color[p[z]] = black
    ,              - color[p[p[z]]] = red
    ,              - right-rotate(T, p[p[z]])
    ,        - else                  # y is the left uncle
    ,          - if color[y] = RED
    ,            - then color[p[z]] = BLACK
    ,              - color[y] = BLACK
    ,              - color[p[p[z]]] = RED
    ,              - z = p[p[z]]
    ,            - else if z = left[p[z]]
    ,                - then z = p[z]
    ,                  - right-rotate(T, z)
    ,              - color[p[z]] = BLACK
    ,              - color[p[p[z]]] = RED
    ,              - left-rotate(T, p[p[z]])
    ,    - color[root[T]] = black
  #+END_SRC
** Exercises
*** 13.3-1
    Coloring $z$ black would have immediate consequences for the
    tree's black-height; whereas a red $z$ is black-height-neutral
    (the black-height can be adjusted by subsequent calls to
    rb-insert-fixup, if necessary).
*** 13.3-2
#+INCLUDE: "13.3-2.dot" src dot
#+CAPTION: Red-black tree after inserting 41, 38, 31, 12, 19, 8
    [[./13.3-2.png]]
* Implementation
** DONE rotation
   CLOSED: [2010-08-31 Tue 19:10]
   #+BEGIN_SRC scheme
     (use defstruct debug test)
     
     ;;; common-enough name; maybe importers can import it as
     ;;; red-black-node, if need be?
     (defstruct node color key left right parent)
     
     ;;; it turns out that the parent, etc. of nil may well be set during
     ;;; algos; pathological?
     (define nil (make-node color: 'black
                            key: #f
                            left: #f
                            right: #f
                            parent: #f))
     
     (define (node-null? node)
       (eq? node nil))
     
     ;;; have these things return the new root?
     (define (left-rotate! root rotandum)
       (let ((rotator (node-right rotandum)))
         (node-right-set! rotandum (node-left rotator))
         (if (not (node-null? (node-left rotator)))
             (node-parent-set! (node-left rotator) rotandum))
         (node-parent-set! rotator
                           (node-parent rotandum))
         (if (node-null? (node-parent rotandum))
             (set! root rotator)
             (if (eq? rotandum (node-left (node-parent rotandum)))
                 (node-left-set! (node-parent rotandum) rotator)
                 (node-right-set! (node-parent rotandum) rotator)))
         (node-left-set! rotator rotandum)
         (node-parent-set! rotandum rotator)
         root))
     
     (define (right-rotate! root rotandum)
       (let ((rotator (node-left rotandum)))
         (node-left-set! rotandum (node-right rotator))
         (if (not (node-null? (node-right rotator)))
             (node-parent-set! (node-right rotator) rotandum))
         (node-parent-set! rotator
                           (node-parent rotandum))
         (if (node-null? (node-parent rotandum))
             (set! root rotator)
             (if (eq? rotandum (node-right (node-parent rotandum)))
                 (node-right-set! (node-parent rotandum) rotator)
                 (node-left-set! (node-parent rotandum) rotator)))
         (node-right-set! rotator rotandum)
         (node-parent-set! rotandum rotator)
         root))
     
     (define (tree->pre-order-list node)
       (if (and (node? node) (not (node-null? node)))
           (list node
                 ;; could refrain from doing these in the case of nil, or
                 ;; even adjust the LIST above.
                 (tree->pre-order-list (node-left node))
                 (tree->pre-order-list (node-right node)))
           nil))
     
     ;; (trace tree->pre-order-list)
     
     (define (nested-map f tree)
       (if (pair? tree)
           (map (cut nested-map f <>) tree)
           (f tree)))
     
     (define (tree->pre-order-key-list root)
       (nested-map node-key (tree->pre-order-list root)))
     
     (let ((node-38 (make-node color: 'black
                               key: 38
                               parent: nil))
           (node-21 (make-node color: 'red
                               key: 21
                               left: nil
                               right: nil))
           (node-41 (make-node color: 'black
                               key: 41
                               left: nil
                               right: nil))
           (node-51 (make-node color: 'black
                               key: 51
                               left: nil
                               right: nil))
           (node-39 (make-node color: 'black
                               key: 39
                               left: nil
                               right: nil))
           (pre-order-key-list '(38 (21 #f #f) (41 (39 #f #f) (51 #f #f))))
           (left-rotated-pre-order-key-list '(41 (38 (21 #f #f) (39 #f #f)) (51 #f #f))))
       (node-left-set! node-38 node-21)
       (node-right-set! node-38 node-41)
       (node-left-set! node-41 node-39)
       (node-right-set! node-41 node-51)
       (node-parent-set! node-21 node-38)
       (node-parent-set! node-41 node-38)
       (node-parent-set! node-39 node-41)
       (node-parent-set! node-51 node-41)
       (test
        "tree structure"
        pre-order-key-list
        (tree->pre-order-key-list node-38))
       (let ((left-rotated-root (left-rotate! node-38 node-38)))
         (test
          "left rotation"
          left-rotated-pre-order-key-list
          (tree->pre-order-key-list left-rotated-root))
         (let ((right-rotated-root (right-rotate! left-rotated-root left-rotated-root)))
           (test
            "right rotation inverse of left rotation"
            pre-order-key-list
            (tree->pre-order-key-list right-rotated-root)))))
   #+END_SRC
** DONE insert without fixup
   CLOSED: [2010-09-01 Wed 01:46]
   #+BEGIN_SRC scheme
     (load "red-black-tree.scm")
     (use red-black-tree debug test)
     
     ;;; NOOP
     (define insert-fixup! values)
     
     (define (insert! root inserendum)
       (let-values
           (((x y)
             (let find-leaf ((x root)
                             (y nil))
               (if (node-null? x)
                   (values x y)
                   ;; what happens if we're dealing with sentinel whose key
                   ;; is non-numeric?
                   (find-leaf (if (< (node-key inserendum)
                                     (node-key x))
                                  (node-left x)
                                  (node-right x))
                              x)))))
         (node-parent-set! inserendum y)
         (if (node-null? y)
             (set! root inserendum)
             (if (< (node-key inserendum)
                    (node-key y))
                 (node-left-set! y inserendum)
                 (node-right-set! y inserendum)))
         (node-left-set! inserendum nil)
         (node-right-set! inserendum nil)
         (node-color-set! inserendum 'red)
         (insert-fixup! root inserendum)
         root))
     
     (define (tree->pre-order-key-color-list root)
       (nested-map (lambda (node) (cons (node-key node)
                                        (node-color node)))
                   (tree->pre-order-list root)))
     
     (let* ((root nil)
            (root (insert! root (make-node key: 11)))
            (root (insert! root (make-node key: 2)))
            (root (insert! root (make-node key: 7)))
            (root (insert! root (make-node key: 5)))
            (root (insert! root (make-node key: 4)))
            (root (insert! root (make-node key: 8)))
            (root (insert! root (make-node key: 1)))
            (root (insert! root (make-node key: 14)))
            (root (insert! root (make-node key: 15))))
       (test
        "insert without fixup"
        '((11 . red)
          ((2 . red)
           ((1 . red) (#f . black) (#f . black))
           ((7 . red)
            ((5 . red) ((4 . red) (#f . black) (#f . black)) (#f . black))
            ((8 . red) (#f . black) (#f . black))))
          ((14 . red) (#f . black) ((15 . red) (#f . black) (#f . black))))
        (tree->pre-order-key-color-list root)))
   #+END_SRC
** DONE fixup
   CLOSED: [2010-09-01 Wed 02:38]
   #+BEGIN_SRC scheme
     (load "red-black-tree.scm")
     (use red-black-tree debug test)
     
     (define (red? node)
       (eq? (node-color node) 'red))
     
     ;;; some assumptions here about the binarism of color (might be
     ;;; surprised, for instance, if we have inconsistent data).
     (define (black? node)
       (not (red? node)))
     
     (define node-grand-parent (compose node-parent node-parent))
     
     (define node-left-uncle (compose node-left node-grand-parent))
     
     (define node-right-uncle (compose node-right node-grand-parent))
     
     (define (insert-fixup! root fixandum)
       (let resolve-upward-until-black-parent ((fixandum fixandum))
         (let ((parent (node-parent fixandum))
               (grand-parent (node-grand-parent fixandum)))
           (if (red? parent)
               (if (eq? parent (node-left-uncle fixandum))
                   (let ((uncle (node-right-uncle fixandum)))
                     (if (red? uncle)
                         (begin
                           (node-color-set! parent 'black)
                           (node-color-set! uncle 'black)
                           (node-color-set! grand-parent 'red)
                           (resolve-upward-until-black-parent grand-parent))
                         (let ((fixandum (if (eq? fixandum (node-right parent))
                                             (begin
                                               (set! root (left-rotate! root parent))
                                               parent)
                                             fixandum)))
                           ;; have to revert to node-parent, etc. here
                           ;; because fixandum may have changed.
                           (node-color-set! (node-parent fixandum) 'black)
                           (node-color-set! (node-grand-parent fixandum) 'red)
                           (set! root (right-rotate! root (node-grand-parent fixandum))))))
                   (let ((uncle (node-left-uncle fixandum)))
                     (if (red? uncle)
                         (begin
                           (node-color-set! parent 'black)
                           (node-color-set! uncle 'black)
                           (node-color-set! grand-parent 'red)
                           (resolve-upward-until-black-parent grand-parent))
                         (let ((fixandum (if (eq? fixandum (node-left parent))
                                             (begin
                                               (set! root (right-rotate! root parent))
                                               parent)
                                             fixandum)))
                           ;; have to revert to node-parent, etc. here
                           ;; because fixandum may have changed.
                           (node-color-set! (node-parent fixandum) 'black)
                           (node-color-set! (node-grand-parent fixandum) 'red)
                           (set! root (left-rotate! root (node-grand-parent fixandum))))))))))
       (node-color-set! root 'black)
       root)
     
     (let* ((root nil)
            (root (insert! root (make-node key: 7)))
            (root (insert! root (make-node key: 2)))
            (root (insert! root (make-node key: 5)))
            (root (insert! root (make-node key: 4)))
            (root (insert! root (make-node key: 1)))
            (root (insert! root (make-node key: 11)))
            (root (insert! root (make-node key: 14)))
            (root (insert! root (make-node key: 15)))
            (root (insert! root (make-node key: 8))))
       (test
        "insert with fixup"
        '((5 . black)
          ((2 . black)
           ((1 . red) (#f . black) (#f . black))
           ((4 . red) (#f . black) (#f . black)))
          ((11 . red)
           ((7 . black) (#f . black) ((8 . red) (#f . black) (#f . black)))
           ((14 . black) (#f . black) ((15 . red) (#f . black) (#f . black)))))
        (tree->pre-order-key-color-list root)))
   #+END_SRC
