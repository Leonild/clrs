(define (construct-optimal-bst root)
  (let* ((n (car (array-dimensions root)))
         (parents (make-stack (make-vector n #f) -1))
         (iter
          (rec (iter i j)
               (if (> i j)
                   (let ((parent (peek parents)))
                     (format #t "d~A is the ~A of k~A~%"
                             j
                             (if (< j parent)
                                 "left"
                                 "right")
                             parent))
                   (let ((r (array-ref root i j)))
                     (if (empty? parents)
                         (format #t "k~A is the root~%" r)
                         (let ((parent (peek parents)))
                           (format #t "k~A is the of ~A child of k~A~%"
                                   r
                                   (if (< i parent)
                                       "left"
                                       "right")
                                   parent)))
                     (push! parents r)
                     (iter i (- r 1))
                     (iter (+ r 1) j)
                     (pop! parents))))))
    (iter 0 (- n 1))
    (values)))

(define (make-optimal-bst roots)
  (let* ((n (car (array-dimensions roots)))
         (root #f)
         (parents (make-stack (make-vector n #f) -1))
         (iter
          (rec (iter i j)
               (if (> i j)
                   (let ((node (make-node j (format "d~A" j) #f #f #f)))
                     (let* ((parent (peek parents))
                            (r (node-key parent)))
                       (set-node-parent! node parent)
                       (if (< j r)
                           (set-node-left! parent node)
                           (set-node-right! parent node))))
                   (let* ((r (array-ref roots i j))
                          (node (make-node r (format "k~A" r) #f #f #f)))
                     (if (empty? parents)
                         (set! root node)
                         (let* ((parent (peek parents))
                                (r (node-key parent)))
                           (set-node-parent! node parent)
                           (if (< i r)
                               (set-node-left! parent node)
                               (set-node-right! parent node))))
                     (push! parents node)
                     (iter i (- r 1))
                     (iter (+ r 1) j)
                     (pop! parents))))))
    (iter 0 (- n 1))
    root))
