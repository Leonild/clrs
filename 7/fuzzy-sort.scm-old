(define-record-type :interval
  (make-interval lower upper)
  interval?
  (lower lower)
  (upper upper))

(define (interval->list interval)
  (list (lower interval) (upper interval)))

(define (compare-lowers comparans comparandum comparator)
  (comparans (lower comparandum) (lower comparator)))

(define (overlap? comparandum comparator)
  (and (>= (upper comparandum)
           (lower comparator))
       (<= (lower comparandum)
           (upper comparator))))

(define swaps 0)

(define (fuzzy-partition! vector p r)
  (let ((x (vector-ref vector r))
        (i (- p 1))
        (j (iota (- r p) p)))
    (for-each
     (lambda (j)
       (let ((ref (vector-ref vector j)))
         (if (compare-lowers <= ref x)
             (begin (set! swaps (+ swaps 1))
                    (format #t "medial-swap, i: ~A; j: ~A; swaps: ~A~%" (+ i 1) j swaps)
                    (set! i (+ i 1))
                    (swap! vector i j)))))
     j)
    (set! swaps (+ swaps 1))
    (format #t "post-swap, i: ~A; j: ~A; swaps: ~A~%" (+ i 1) r swaps)
    (swap! vector (+ i 1) r)
;;;     (let ((ref (vector-ref vector (+ i 1)))
;;;           (vector-length (vector-length vector)))
;;;       (let loop ((i (+ i 1)))
;;;         (if (< i vector-length)
;;;             (if (overlap? ref (vector-ref vector i))
;;;                 (begin
;;;                   (format #t "overlappeth, ref: ~A; i-ref: ~A~%"
;;;                           (interval->list ref)
;;;                           (interval->list (vector-ref vector i)))
;;;                   (loop (+ i 1)))
;;;                 (- i 1))
;;;             (- i 1))))
    (let ((ref (vector-ref vector (+ i 1)))
          (vector-length (vector-length vector)))
      (let loop ((i (+ i 1)))
        (if (>= i 0)
            (if (overlap? ref (vector-ref vector i))
                (begin
                  (format #t "overlappeth, ref: ~A; i-ref: ~A~%"
                          (interval->list ref)
                          (interval->list (vector-ref vector i)))
                  (loop (- i 1)))
                (+ i 1))
            i)))
;;;     (+ i 1)
    ))

(define (fuzzy-quicksort! vector p r)
  (display (vector-map (lambda (i x) (interval->list x)) vector))
  (newline)
  (if (< p r)
      (let ((q (fuzzy-partition! vector p r)))
        (if
;;;          (<= q r)
         (>= q 0)
         (begin
           (format #t "quicksort first, p: ~A; (- q 1): ~A~%"
                   p (- q 1))
           (fuzzy-quicksort! vector p (- q 1))))
        (if
         (>= q 0)
         (begin (format #t "quicksort second, (+ q 1): ~A; r: ~A~%"
                        (+ q 1) r)
                (fuzzy-quicksort! vector (+ q 1) r))))
      (format #t "quicksort end, p: ~A; r: ~A~%"
              p r)))
