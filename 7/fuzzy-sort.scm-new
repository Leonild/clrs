(define-record-type :interval
  (make-interval lower upper)
  interval?
  (lower lower)
  (upper upper))

(define (interval->list interval)
  (list (lower interval) (upper interval)))

(define (compare-lowers comparans comparandum comparator)
  (comparans (lower comparandum) (lower comparator)))

(define (orthogonal? comparandum comparator)
  (not (overlap? comparandum comparator)))

(define (overlap? comparandum comparator)

  (format #t
          "overlap?, ~A ~A ~A~%"
          (interval->list comparandum)
          (interval->list comparator)
          (and (>= (upper comparandum)
                   (lower comparator))
               (<= (lower comparandum)
                   (upper comparator))))
    (and (>= (upper comparandum)
           (lower comparator))
       (<= (lower comparandum)
           (upper comparator))))

(define swaps 0)

(define (fuzzy-partition! vector p r)
  (let ((x (vector-ref vector r))
        (i (- p 1))
        (j (iota (- r p) p)))
    (for-each
     (lambda (j)
       (let ((ref (vector-ref vector j)))
         (if (and (orthogonal? ref (vector-ref vector j))
                  (compare-lowers <= ref x))
             (begin (set! swaps (+ swaps 1))
                    (format #t "medial-swap, i: ~A; j: ~A; swaps: ~A~%" (+ i 1) j swaps)
                    (set! i (+ i 1))
                    (swap! vector i j)))))
     j)
    (set! swaps (+ swaps 1))
    (if (orthogonal? (vector-ref vector (+ i 1))
                     (vector-ref vector r))
        (format #t "post-swap, i: ~A; j: ~A; swaps: ~A~%" (+ i 1) r swaps)
        (swap! vector (+ i 1) r))
    (+ i 1)
    ))

(define (fuzzy-quicksort! vector p r)
  (display (vector-map (lambda (i x) (interval->list x)) vector))
  (newline)
  (if (< p r)
      (let ((q (fuzzy-partition! vector p r)))
        (begin
          (format #t "quicksort first, p: ~A; (- q 1): ~A~%"
                  p (- q 1))
          (fuzzy-quicksort! vector p (- q 1)))
        (begin (format #t "quicksort second, (+ q 1): ~A; r: ~A~%"
                       (+ q 1) r)
               (fuzzy-quicksort! vector (+ q 1) r)))
      (format #t "quicksort end, p: ~A; r: ~A~%"
              p r)))
