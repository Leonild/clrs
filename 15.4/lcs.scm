(define (lcs-length X Y)
  (let ((m (length X))
        (n (length Y)))
    (let ((c (make-array '#(0) `(-1 ,m) `(-1 ,n)))
          (b (make-array '#(#f) `(-1 ,m) `(-1 ,n))))
      (loop ((for i (up-from 0 (to m))))
            (loop ((for j (up-from 0 (to n))))
                  (if (eq? (list-ref X i) (list-ref Y j))
                      (begin
                        (array-set! c (+ (array-ref c (- i 1) (- j 1)) 1) i j)
                        (array-set! b '(-1 . -1) i j))
                      (let ((up (array-ref c (- i 1) j))
                            (left (array-ref c i (- j 1))))
                        (if (>= up left)
                            (begin
                              (array-set! c up i j)
                              (array-set! b '(-1 . 0) i j))
                            (begin
                              (array-set! c left i j)
                              (array-set! b '(0 . -1) i j)))))))
      (values c b))))

(define (lcs-length/2n X Y)
  (let ((m (length X))
        (n (length Y)))
    (let ((previous (make-array '#(0) `(-1 ,n)))
          (current (make-array '#(0) `(-1 ,n))))
      (loop ((for i (up-from 0 (to m))))
            (loop ((for j (up-from 0 (to n))))
                  (if (eq? (list-ref X i) (list-ref Y j))
                      (array-set! current (+ (array-ref previous (- j 1)) 1) j)
                      (let ((up (array-ref previous j))
                            (left (array-ref current (- j 1))))
                        (if (>= up left)
                            (array-set! current up j)
                            (array-set! current left j)))))
            (array-copy! previous current))
      (last (array->list current)))))

(define (lcs-length/n X Y)
  (let ((m (length X))
        (n (length Y)))
    (let ((row (make-array '#(0) `(-1 ,n)))
          (current 0))
      (loop ((for i (up-from 0 (to m))))
            (set! current 0)
            (loop ((for j (up-from 0 (to n))))
                  (let ((diag (array-ref row (- j 1)))
                        (up (array-ref row j))
                        (left current))
                    (if (eq? (list-ref X i) (list-ref Y j))
                        (set! current (+ diag 1))
                        (if (>= up left)
                            (set! current up)
                            (set! current left)))
                    (array-set! row left (- j 1))))
            (array-set! row current (- n 1)))
      current)))

(define (lcs b X i j)
  (if (or (negative? i) (negative? j))
      '()
      (let ((displacement (array-ref b i j))
            (up-left? (lambda (displacement)
                        (equal? displacement '(-1 . -1)))))
        (let ((next (if (up-left? displacement)
                        (list (list-ref X i))
                        '())))
          (append (lcs b X (+ i (car displacement)) (+ j (cdr displacement)))
                  next)))))

(define (lcs/c c X Y)
  (define (iter l i j)
    (if (or (negative? i) (negative? j))
        l
        (let ((up (array-ref c (- i 1) j))
              (left (array-ref c i (- j 1)))
              (up-left (array-ref c (- i 1) (- j 1)))
              (this (array-ref c i j)))
          (if (equal? (list-ref X i) (list-ref Y j))
              (iter (cons (list-ref X i) l) (- i 1) (- j 1))
              (if (= this up)
                  (iter l (- i 1) j)
                  (iter l i (- j 1)))))))
  (iter '() (- (length X) 1) (- (length Y) 1)))

(define (memoized-lcs-length X Y)
  (let ((m (length X))
        (n (length Y)))
    (let ((c (make-array '#(#f) `(-1 ,m) `(-1 ,n))))
      ;; Why not add them as special cases?
      (loop ((for i (up-from -1 (to m))))
            (array-set! c 0 i -1))
      (loop ((for j (up-from -1 (to n))))
            (array-set! c 0 -1 j))
      (letrec ((iter
                (lambda (i j)
                  (let ((memo (array-ref c i j)))
                    (if memo
                        memo
                        (let ((new-memo
                               (if (equal? (list-ref X i) (list-ref Y j))
                                   (+ (iter (- i 1) (- j 1)) 1)
                                   (max (iter (- i 1) j) (iter i (- j 1))))))
                          (array-set! c new-memo i j)
                          new-memo))))))
        (iter (- m 1) (- n 1)))
      c)))

(define (longest-increasing-subsequence X)
  (let ((Y (heapsort X)))
    (lcs/c (memoized-lcs-length X Y) X Y)))
