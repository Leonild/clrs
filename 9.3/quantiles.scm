(define (quantile-statistics A p r k)
  (let* ((n (vector-length A))
         (statistics (map (lambda (quantile)
                            (exact-floor (/ (* quantile n) k)))
                          (iota (- k 1) 1))))
    (filter (lambda (statistic)
              (and (>= statistic p)
                   (<= statistic r)))
            statistics)))

(define (kth-quantiles! A k)
  (let ((quantiles '()))
    (let continue ((p 0)
                   (r (- (vector-length A) 1)))
      (let* ((statistics (quantile-statistics A p r k))
             (pivot-statistic
              (if (null? statistics)
                  0
                  (list-ref statistics (exact-floor (/ (length statistics) 2))))))
        (if (null? statistics)
            quantiles
            (let ((x (randomized-select A p r (+ (- pivot-statistic p) 1))))
              (set! quantiles (cons x quantiles))
              (partition-k! A p r pivot-statistic)
              (continue p (- pivot-statistic 1))
              (continue (+ pivot-statistic 1) r)))))))

(define (k-medial-proximals! A k)
  (let* ((length (vector-length A))
         (medial (lower-median length))
         (median (vector-ref A (- medial 1))))
    (partition-median! A 0 (- length 1))
    (loop continue ((until (= k 0))
                    (with k k)
                    (with i medial)
                    (with j (- medial 1))
                    (with proximals '()))
          => proximals
          (let ((upper (vector-ref A i))
                (lower (vector-ref A j)))
            (let ((upper-delta (if (>= i length) +inf.0 (abs (- median upper))))
                  (lower-delta (if (<= j 0) +inf.0 (abs (- median lower)))))
              (if (< upper-delta lower-delta)
                  (continue (=> k (- k 1))
                            (=> i (+ i 1))
                            (=> proximals (cons upper proximals)))
                  (continue (=> k (- k 1))
                            (=> j (- j 1))
                            (=> proximals (cons lower proximals)))))))))

(define (dual-medians A B)
  (define (binary-search A B n low high)
    (if (> low high)
        #f
        (let ((k (exact-floor (/ (+ low high) 2))))
          (let ((An (list-ref A n))
                (Ak (list-ref A k)))
            (cond ((and (= k n) (<= An (car B))) An)
                  ((and (< k n) (<= (list-ref B (- n k 1))
                                    Ak
                                    (list-ref B (- n k))))
                   Ak)
                  ((> Ak (list-ref B (- n k)))
                   (binary-search A B n low (- k 1)))
                  (else (binary-search A B n (+ 1 k) high)))))))
  (let* ((n (- (length A) 1))
         (premedian (binary-search A B n 0 n))
         (median (if premedian
                     premedian
                     (binary-search B A n 0 n))))
    median))
